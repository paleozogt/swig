<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>SWIG and C as the target language</title>
<link rel="stylesheet" type="text/css" href="style.css">
</head>
<body bgcolor="#FFFFFF">
<H1><a name="C"></a>36 SWIG and C as the target language</H1>
<!-- INDEX -->
<div class="sectiontoc">
<ul>
<li><a href="#C_overview">Overview</a>
<li><a href="#C_preliminaries">Preliminaries</a>
<ul>
<li><a href="#C_running_swig">Running SWIG</a>
<li><a href="#C_commandline">Command line options</a>
<li><a href="#C_dynamic">Compiling dynamic module</a>
<li><a href="#C_using_module">Using generated module</a>
</ul>
<li><a href="#C_basic_c_wrapping">Basic C wrapping</a>
<ul>
<li><a href="#C_functions">Functions</a>
<li><a href="#C_variables">Variables</a>
</ul>
<li><a href="#C_basic_cpp_wrapping">Basic C++ wrapping</a>
<ul>
<li><a href="#C_classes">Classes</a>
</ul>
<li><a href="#C_exceptions">Exception handling</a>
</ul>
</div>
<!-- INDEX -->



<p>
This chapter describes SWIG's support for creating ANSI C wrappers. This module has a special purpose and thus is different from most other modules.
</p>

<p>
<b>NOTE:</b> this module is still under development.
</p>


<H2><a name="C_overview"></a>36.1 Overview</H2>


<p>
SWIG is normally used to provide access to C or C++ libraries from target languages such as scripting languages or languages running on a virtual machine. 
SWIG performs analysis of the input C/C++ library header files from which it generates further code. For most target languages this code consists of two layers; namely an intermediary C code layer and a set of language specific proxy classes and functions on top of the C code layer. 
We could also think of C as just another target language supported by SWIG.
The aim then is to generate a pure ANSI C interface to the input C or C++ library and hence the C target language module.
</p>

<p>
With wrapper interfaces generated by SWIG, it is easy to use the functionality of C++ libraries inside application code written in C. This module may also be useful to generate custom APIs for a library, to suit particular needs, e.g. to supply function calls with error checking or to implement a "design by contract".
</p>

<p>
Flattening C++ language constructs into a set of C-style functions obviously comes with many limitations and inconveniences. All data and functions become global. Manipulating objects requires explicit calls to special functions. We are losing the high level abstraction and have to work around it.
</p>

<H2><a name="C_preliminaries"></a>36.2 Preliminaries</H2>


<H3><a name="C_running_swig"></a>36.2.1 Running SWIG</H3>


<p>
Consider the following simple example. Suppose we have an interface file like:
</p>

<div class="code">
<pre>
/* File: example.i */
%module test
%{
#include "stuff.h"
%}
int fact(int n);
</pre>
</div>

<p>
To build a C module (C as the target language), run SWIG using the <tt>-c</tt> option :</p>

<div class="code"><pre>
%swig -c example.i
</pre></div>

<p>
The above assumes C as the input language. If the input language is C++ add the <tt>-c++</tt> option:
</p>

<div class="code"><pre>
$ swig -c++ -c example.i
</pre></div>

<p>
Note that <tt>-c</tt> is the option specifying the <b>target</b> language and <tt>-c++</tt> controls what the <b>input</b> language is.
<p>

<p>
This will generate an <tt>example_wrap.c</tt> file or, in the latter case, <tt>example_wrap.cxx</tt> file, along with <tt>example_proxy.h</tt> and <tt>example_proxy.c</tt> files. The name of the file is derived from the name of the input file. To change this, you can use the <tt>-o</tt> option common to all language modules. 
</p>

<p>
The <tt>wrap</tt> file contains the wrapper functions, which perform the main functionality of SWIG: it translates the input arguments from C to C++, makes calls to the original functions and marshalls C++ output back to C data. The <tt>proxy</tt> header file contains the interface we can use in C application code. The additional <tt>.c</tt> file contains calls to the wrapper functions, allowing us to preserve names of the original functions.
</p>

<H3><a name="C_commandline"></a>36.2.2 Command line options</H3>


<p>
The following table list the additional commandline options available for the C module. They can also be seen by using: 
</p>

<div class="code"><pre>
swig -c -help 
</pre></div>

<table summary="C specific options">
<tr>
<th>C specific options</th>
</tr>

<tr>
<td>-noproxy</td>
<td>do not generate proxy files (i.e. <i>filename</i><tt>_proxy.h</tt> and <i>filename</i><tt>_proxy.c</tt>)</td>
</tr>

<tr>
<td>-noexcept</td>
<td>generate wrappers with no support of exception handling; see <a href="#C_exceptions">Exceptions</a> chapter for more details </td>
</tr>

</table>

<H3><a name="C_dynamic"></a>36.2.3 Compiling a dynamic module</H3>


<p>
The next step is to build a dynamically loadable module, which we can link to our application. This can be done easily, for example using the <tt>gcc</tt> compiler (Linux, MinGW, etc.):
</p>

<div class="code"><pre>
$ swig -c example.i
$ gcc -c example_wrap.c  
$ gcc -shared example_wrap.o -o libexample.so
</pre></div>

<p>
Or, for C++ input:
</p>

<div class="code"><pre>
$ swig -c++ -c example.i
$ g++ -c example_wrap.c  
$ g++ -shared example_wrap.o -o libexample.so
</pre></div>

<p>
Now the shared library module is ready to use. Note that the name of the generated module is important: is should be prefixed with <tt>lib</tt> on Unix, and have the specific extension, like <tt>.dll</tt> for Windows or <tt>.so</tt> for Unix systems.
</p>

<H3><a name="C_using_module"></a>36.2.4 Using the generated module</H3>


<p>
The simplest way to use the generated shared module is to link it to the application code during the compilation stage. We have to compile the proxy file as well. The process is usually similar to this:
</p>

<div class="code"><pre>
$ gcc runme.c example_proxy.c -L. -lexample -o runme
</pre></div>

<p>
This will compile the application code (<tt>runme.c</tt>), along with the proxy code and link it against the generated shared module. Following the <tt>-L</tt> option is the path to the directory containing the shared module. The output executable is ready to use. The last thing to do is to supply to the operating system the information of location of our module. This is system dependant, for instance Unix systems look for shared modules in certain directories, like <tt>/usr/lib</tt>, and additionally we can set the environment variable <tt>LD_LIBRARY_PATH</tt> (Unix) or <tt>PATH</tt> (Windows) for other directories.
</p>

<H2><a name="C_basic_c_wrapping"></a>36.3 Basic C wrapping</H2>


<p>
Wrapping C functions and variables is obviously performed in a straightforward way. There is no need to perform type conversions, and all language constructs can be preserved in their original form. However, SWIG allows you to enchance the code with some additional elements, for instance using <tt>check</tt> typemap or <tt>%extend</tt> directive.
</p>

<H3><a name="C_functions"></a>36.3.1 Functions</H3>


<p>
For each C function declared in the interface file a wrapper function is created. Basically, the wrapper function performs a call to the original function, and returns its result.
</p>

<p>
For example, for function declaration:
</p>

<div class="code"><pre>
int gcd(int x, int y);
</pre></div>

<p>
The output is simply:
</p>

<div class="code"><pre>
int _wrap_gcd(int arg1, int arg2) {
  int result;
  result = gcd(arg1,arg2);
  return result;
}
</pre></div>

<p>
Then again, this wrapper function is usually called from C using helper function declared in proxy file, preserving the original name:
</p>

<div class="code"><pre>
int gcd(int arg1, int arg2) {
  return _wrap_gcd(arg1,arg2);
}
</pre></div>

<p>
Now one might think, what's the use of creating such functions in C? The answer is, you can apply special rules to the generated code. Take for example constraint checking. You can write a "check" typemap in your interface file:
</p>

<div class="code"><pre>
%typemap(check) int POSITIVE {
  if ($1 <= 0)
    fprintf(stderr, "Expected positive value in $name.\n");
}

int gcd(int POSITIVE, int POSITIVE);
</pre></div>

<p>
And now the generated result looks like:
</p>

<div class="code"><pre>
int _wrap_gcd(int arg1, int arg2) {
  {
    if (arg1 <= 0)
      fprintf(stderr, "Expected positive value in gcd.\n");
  }
  {
    if (arg1 <= 0)
      fprintf(stderr, "Expected positive value in gcd.\n");
  }
  int result;
  result = gcd(arg1,arg2);
  return result;
}
</pre></div>

<p>
This time calling <tt>gcd</tt> with negative value argument will trigger an error message. This can save you time writing all the constraint checking code by hand.
</p>

<H3><a name="C_variables"></a>36.3.2 Variables</H3>


<p>
Wrapping variables comes also without any special issues. All global variables are directly accessible from application code. There is a difference in the semantics of <tt>struct</tt> definition in C and C++. When handling C <tt>struct</tt>, SWIG simply rewrites its declaration. In C++ <tt>struct</tt> is handled as class declaration. 
</p>

<p>
You can still apply some of the SWIG features when handling structs, e.g. <tt>%extend</tt> directive. Suppose, you have a C struct declaration:
</p>

<div class="code"><pre>
typedef struct {
  int x;
  char *str;
} my_struct;
</pre></div>

<p>
You can redefine it to have an additional fields, like:
</p>

<div class="code"><pre>
%extend my_struct {
  double d;
};
</pre></div>

<p>
In application code:
</p>

<div class="targetlang"><pre>
struct my_struct ms;
ms.x = 123;
ms.d = 123.123;
</pre></div>

<H2><a name="C_basic_cpp_wrapping"></a>36.4 Basic C++ wrapping</H2>


<p>
The main reason of having the C module in SWIG is to be able to access C++ from C. In this chapter we will take a look at the rules of wrapping elements of the C++ language.
</p>

<H3><a name="C_classes"></a>36.4.1 Classes</H3>


<p>
Consider the following example. We have a C++ class, and want to use it from C code.
</p>

<div class="code"><pre>
class Circle {
public:
  double radius;

  Circle(double r) : radius(r) { };
  double area(void);
};
</pre></div>

<p>
What we need to do is to create an object of the class, manipulate it, and finally, destroy it. SWIG generates C functions for this purpose each time a class declaration is encountered in the interface file.
</p>

<p>
The first two generated functions are used to create and destroy instances of class <tt>Circle</tt>. Such instances are represented on the C side as pointers to special structs, called <tt>SwigObj</tt>. They are all "renamed" (via typedef) to the original class names, so that you can use the object instances on the C side using pointers like:
</p>

<div class="targetlang"><pre>
Circle *circle;
</pre></div>

<p>
The generated functions make calls to class' constructors and destructors, respectively. They also do all the necessary things required by the SWIG object management system in C.
</p>

<div class="code"><pre>
Circle * new_Circle(double r);
void delete_Circle(Circle * self);
</pre></div>

<p>
The class <tt>Circle</tt> has a public variable called <tt>radius</tt>. SWIG generates a pair of setters and getters for each such variable:
</p>

<div class="code"><pre>
void Circle_radius_set(Circle * self, double radius);
double Circle_radius_get(Circle * self);
</pre></div>

<p>
For each public method, an appropriate function is generated:
</p>

<div class="code"><pre>
double Circle_area(Circle * self);
</pre></div>

<p>
You can see that in order to use the generated object we need to provide a pointer to the object instance (struct <tt>Circle</tt> in this case) as the first function argument. In fact, this struct is basically wrapping pointer to the "real" C++ object.
</p>

<p>
Our application code could look like this:
</p>

<div class="targetlang"><pre>
  Circle *c = new_Circle(1.5);
  printf("radius: %f\narea: %f\n", Circle_radius_get(c), Circle_area(c));
  delete_Circle(c);
</pre></div>

<p>
After running this we'll get:
</p>

<div class="shell"><pre>
radius: 1.500000
area: 7.068583
</pre></div>

<H2><a name="C_exceptions"></a>36.5 Exception handling</H2>


</body>
</html>


